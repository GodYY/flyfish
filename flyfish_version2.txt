flyfish

flyfish的定位是缓存系统，其数据最终被落地到后端sql数据库中。




flyfish数据流



读取

1）客户端向flyfish请求获取key关联的数据,flyfish首先查找本地是否有缓存(被删除的key在flyfish中也有记录，标记为缺失),有跳到步骤3。

2）从sql数据库读取数据，将数据信息放到本地缓存(如果数据不存在，建立对应的key标记为缺失)。

3）根据缓存状态返回数据或数据不存在的错误码。


变更

1）客户端向flyfish请求获取key关联的数据,flyfish首先查找本地是否有缓存。

2）从sql数据库读取数据，将数据信息放到本地缓存。

3）对数据做变更，生成binlog,将binlog写入回写缓冲区，当缓冲区成功写入到磁盘后，向客户端发回响应。同时向sql数据库发起回写请求。

flyfish对数据安全性的保证

对于用户的变更请求，一旦flyfish发回响应，只要磁盘文件没有损毁即可保证数据不丢失。

本机数据持久化以及sql回写处理

flyfish对所有变更请求产生binlog,在binlog被序列到磁盘后才向用户发回响应并请求sql回写。




binlog



每个请求产生相应的binlog，进程重启时通过回放binlog恢复内存数据。binlog有以下类型

binlog_snapshot|binlog_insert: 记录key关联的全部数据。

binlog_update:记录变更条目。

binlog_delete:删除key。

binlog_kick:key不再被本实例缓存。

当一个key被加入到缓存时，产生一条insert记录，将全量数据写入binlog文件。后续操作产生相应的binlog,当进程重启后，按序执行binlog中的操作即可恢复key的内存状态。

为了防止binlog文件过大，使得重放耗时太长。如果当前binlog文件大小或条目超过一定限制，将启动创建新binlog文件的过程。处理过程如下:

1）关闭当前binlog文件，记录文件名。开启一个新的文件，将所有key保存到一个单独的数组。并将这些key标记为正在执行快照，一防止key被替换。

2）为了避免打快照的过程stop the world,启动一个单独的go程,遍历保存下来的数组，对里面的key产生snapshot类型的binlog。

3）一旦go程处理结束，将之前的文件删除。

快照处理过程与正常操作产生binlog的处理是并行处理的。在快照开始的时候，遍历所有key并保存到单独数据的过程中，将这些key的snapshot标记打为false。
加入key1被排到数组最后。在处理它之前，客户端发出了个update操作，在处理这个key时发现snapshot标记为false,将会对它产生一个insert类型的binlog。
当快照处理go成处理key1的时候，发现它的snapshot标记不为false,就跳过处理。




与sql数据库不一致的情况

如果flyfish没有任何故障，将与sql数据库达成最终一致。

以下情况将出现无法保证最终一致的情况

key1的binlog序列化到磁盘执行sql回写前flyfish崩溃。

重启后内存数据通过binlog回放被恢复。但是key1之后没有再被访问过，这种情况将导致flyfish与sql数据库永远无法对key1达成一致的情况。

为了防止以上情况的发生，flyfish重启回放完成后，需要对所有的key执行一次回写。













