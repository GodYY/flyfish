flyfish纯粹缓存存在一个问题：

flyfish使用磁盘作为缓冲区,缓和了快速的生产者和慢速消费者(sql回写处理)的关系。但是，磁盘和sql的处理速度差距过大,flyfish平均每秒可以处理5-6W条更新操作，
这些操作被写入binlog然后投递给sql执行。只要不超过设置的上限，binlog中可能存在数百万条待回写的操作。一旦服务崩溃之后重启，需要将未执行的binlog提交到sql执行

完成之后服务才能恢复。执行如此大量的binlog将导致恢复时间变得非常漫长。


为此，flyfish准备引入leveldb这样的本地存储引擎。


对于单机flyfish必须满足的安全性保证，只要机器磁盘没有被损坏，并且所有数据访问都通过flyfish,即使在flyfish与db存在数据不一致的情况，也不会出现客户端操作丢失。

flyfish作为一个缓存系统，其缓存的key/value对是有上限的，超过上限将会执行lru替换。flyfish将把缓存的key/value保存到本地存储引擎，具体处理规则如下:

set系列消息:

1) 查询本地，如果存在跳到3)

2) 请求sql加载，如果sql不存在，写入本地存储，生成一条insert交由sql执行，成功向客户端返回。

3) 更新数据，写入本地存储，向客户端返回。

对步骤2的优化，将key的sql操作标记也存入本地存储，存储成功后即可返回客户端。sql操作稍后异步执行。假设一次set操作使得key的sql标记为insert,
当flyfish在写入本地存储，响应客户端执行sql回写前崩溃，此时db中不存在响应条目，后面执行update将会出问题。因为sql标记本持久化，服务重启后
这个标记不会被丢失，下次key再被set时，不会将标记变更为update,所以在回写时依旧使用insert执行。



del系列操作：

1) 查询本地，如果存在跳到3)

2) 请求sql加载，如果sql不存在，向客户端返回错误。

3) 从本地存储删除，生成一条del交由sql执行，客户端返回。

对步骤3的优化，删除本地存储时只删除有效数据，状态不删除(即被删除的key被标记为del），返回响应，del语句异步执行，只有在执行完成后才将整个key从本地存储移除。
假如在返回响应后执行del语句前服务崩溃。服务重启时加载所有的key,一旦发现key被标记为del,立即执行sql删除，直到所有key处理完成后再恢复服务。


get系列操作：

1) 查询本地，如果存在跳到3)

2) 请求sql加载，写入本地存储，向客户端返回。

3) 向客户端返回。


配置回写定时器,当key发生变更设置定时器，定时器到达生成update交由sql执行。

key的替换：

key被替换时，从本地存储移除，如果关联value发生过变更,生成一条update交由sql执行。













