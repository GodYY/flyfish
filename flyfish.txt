flyfish是一个高可用，强一致的kv缓存系统。flyfish有如下特性：

1）使用raft协议实现多副本强一致，提供高可用。
2）支持数据分片，提供动态扩容/缩容
3）对于单个记录，提供基本的事务功能(cas,inc/dec,setnx)。
4）支持版本号，方面客户端实现乐观锁。
5）每个条记录是一个字典结构(映射到关系数据库中的一行),记录中的字段可以独立访问。
6）当后端的关系数据库不可用，对已经在缓存中的数据，flyfish依旧可以提供读写服务并保证数据不丢失(后端数据库不可用,无法加载新的记录到缓存)。
7）异步回写，flyfish与后端关系数据库保持最终一致性。
8）高性能，单节点提供10W+的读写能力。
9）使用protobuf作为对外接口，方便客户端的实现。
10）字段支持int64,uint64,float64,string,blob五种类型。
11) 只有leader能提供读写服务。


kv基本结构

flyfish作为有模式的kv缓存，每条记录映射到关系数据库中的一行。数据库建表时有如下约定：

__key___(vchar,主键唯一),__version___(bigint),自定义字段1,自定义字段2...。

其中__key__,__version__供flyfish使用。tablename:__key__作为字典unikey。

flyfish的数据分片使用字典key的hash值取模进行划分。

客户端访问一个unikey时，如果flyfish没有缓存对应的unikey,flyfish首先向后端关系数据库请求加载(不管记录是否存在，flyfish都会加入相应的记录，如记录在数据库中
不存在，给记录标记不存在)。然后将操作结果返回给客户端。对于更新操作，flyfish通过raft协议完成提交后，将操作结果应用到内存，然后返回客户端响应。并提交一个
异步的sql回写请求。


副本状态同步

flyfish通过raft实现副本之间的强一致。副本之间同步的内容如下(raft log entry以及快照)：

在flyfish中，副本之间同步的条目分为以下三种类型：

snapshot: 完整数据状态，记录了unikey,version,字段(如果记录存在)。对于此类型的条目，执行数据回放的规则如下:

如果内存中不存在，则建立对应的记录(如果version==0表明设置记录缺失标记)。

如果已经存在，用条目中的内容更新记录。

update: 距离上一次snapshot的数据变更,记录了unikey,version,变更的字段。

回放规则:

如果记录在内存中不存在，或被标记为缺失，panic。

否则，用条目中的内容更新记录。

kick:将记录从内存中剔除。

回放规则:

如果记录在内存中不存在，panic。

从内存中删除记录。


对客户端操作的响应

flyfish是强一致，支持线性一致的kv系统，因此客户端的请求必须经过raft协议之后才能被响应。具体处理如下:

只读请求:

如果unikey在内存中不存在，flyfish向后端请求加载记录，加载到数据之后，向所有副本同步一条携带了记录状态的snapshot条目。
当条目被raft接受，将条目内容应用到内存(此处为插入记录)，响应客户端。

如果unikey存在，通过readIndex机制保证线性一致读。


更新请求:

如果unikey在内存中不存在，flyfish向后端请求加载记录，加载到数据之后，将变更字段合并，生成一条snapshot条目，向副本同步，
当条目被raft接受，将条目内容应用到内存(此处为插入记录)，响应客户端。

如unikey存在，将变更内容封装到update条目中，向副本同步，当条目被raft接受，将条目内容应用到内存，响应客户端。


flyfish保证，只要响应了客户端，变更就不会丢失(除非所有接收到条目的副本磁盘都损毁)。因为flyfish内存与sql数据库保证的是最终一致性，
此时如果直接查询sql数据库可能无法获取最新内容。


命令的执行顺序

对于单个unikey，命令是顺序实行的。多个连续的读请求可以被合并成单一命令，一次性返回。前一个命令尚未响应之前，后续命令必须排队等待。



sql回写

flyfish采用异步sql回写，所以内存数据与sql数据在一个时间窗口内无法保证一致，时间窗口的长短取决于sql处理能力。

为了减少sql语句的数量，flyfish不会对每次变更产生一条sql回写请求，而是将发生变更的unikey提交到更新队列，回写处理例程从队列中取出
unikey将所有变更生成一条更新语句并执行回写。因此，sql命令的上限不由更新请求次数决定，而是由内存中unikey的数量决定。

生成的sql语句必须是幂等的，以使得可以安全的重放sql语句。因此，对于insert类语句，需采用insert update语句(mysql:insert into %s(%s) values(%s) on duplicate key update %s,pgsql:INSERT INTO %s(%s) VALUES(%s) ON conflict(__key__)  DO UPDATE SET %s)。

因为回写是异步的，为了防止数据丢失，回写尚未执行完毕的unikey不能被kick出内存。

同时，为了避免在执行回写时节点崩溃而导致的回写丢失。当一个节点成为leader时，需要将自己的所有unikey标记为需要执行回写，并强制执行一次sql回写。


回写乱序导致的数据覆盖

考虑如下场景:

A是leader，执行sql回写前，因为网络分区，集群选举B为leader,此时A尚未感知到自己已经不是leader继续发出sql回写请求。
B此时也收到更新请求，执行回写。如果A回写在B之后执行，将导致老数据覆盖新数据。

为了解决上述问题，sql执行权需要获得lease。且只有leader才可以申请lease。

为此，向raft条目添加一个新的lease类型,其中只包含节点id。

当leader发现目前没有节点持有lease,或前面的lease已经过期，则可以向所有副本同步一条lease条目，当lease被接受，leader就获得了
lease,有权执行sql回写。lease持有者需要定期同步lease条目以维持lease。为了保证lease的正确性,lease的超时时间应当远大于raft的心跳及选举超时时间。

对于上面描述的问题，在A尚未感知到自己已经不是leader时，因为它还持有lease,所以有权继续执行回写,但因为A此时已经不是leader,A的续约请求将无法提交。

而B在等到A的lease超时后才能申请到lease,这就保证了不会出现回写覆盖。


kick锁定

如果leader没有获取lease，在sql回写例程执行时会讲请求直接丢弃。因此，新的leader应该在获得lease才发起一次强制的回写请求。此时，unikey可能因为kick而导致
数据丢失(没有回写标记的保护)。为此，新的leader必须锁定kick处理，全面禁止kick的执行。当获取到lease并提交了强制回写请求时才放开(此时已经有回写标记保护)。

















































































